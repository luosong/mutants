webpackJsonp([44],{3:function(e,n,t){e.exports=t(2)(155)},368:function(e,n,t){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function r(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function a(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}function c(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}Object.defineProperty(n,"__esModule",{value:!0});var u=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),i=t(1),p=o(i),s=t(86),l=(o(s),t(3)),f=o(l),b=t(551),d=o(b),h=function(e){function n(){return r(this,n),a(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return c(n,e),u(n,[{key:"render",value:function(){return p["default"].createElement("div",null,p["default"].createElement(f["default"],{text:d["default"]}))}},{key:"getStyles",value:function(){return{}}}]),n}(i.Component);n["default"]=h},551:function(e,n){e.exports='## 预备知识\n\n在你决定使用Mutants之前,我们假定你已了解 [React](http://facebook.github.io/react/). \n因为React是整个框架的基础条件之一, 所以理解React怎么进行web开发格外重要。\n\n如果你已经熟悉单页面应用 (SPA) 和Node, 你可以轻松的跳过 `预备知识` 。\n\n不然的话, 下面是对 SPA 和 Node 进行的一个快速和简短的介绍。 也许你会觉得有用, 特别是如果你只有\n有限的web开发经验, 或者是使用HTML, CSS,和JavaScript 进行 "传统的" web站点的经验。\n\n\n### 单页面应用程序\n\n在很久(?) 以前, web站点有很多静态HTML页面构成, css用来styling, 用javascript用来进行用户交互和动画。\n大多数客户端交互,特别是有数据处理的, 数据从客户端发送到服务端,服务端处理后返回给客户端,很多情况下, 这种通信是\n"阻塞"式的, 也就是说在这个过程中客户端是处于忙碌状态,不能响应ui交互。\n\n直到异步通信(AJAX)的到来, 客户端才可以做另外一些事情,当数据从发送出到接收到这段时间。然而大多数的客户端交互,特别是\n页面之间的切换还是阻塞的。 web站点让人感觉不到像桌面应用程序那样流畅和及时响应, 这就是 SPA 为什么出现了。\n \n单页面应用程序本质上是一个只有一个HTML页面构的web站点。 整个站点存在于一个文件(通常是一个javascript文件)中,只要从服务端\n 加载一次,绝大多数的客户端交互的逻辑处理都在这一个文件中处理。这样,一旦这个文件加载后,整个站点的操作就像本地应用一样流畅和及时响应。\n近十年来这种开发方式获得了巨大的推进, 一大批优秀的展现层javascript框架涌现出来:  \n\n- [Angular](https://angularjs.org)\n- [Ember](http://emberjs.com/)\n- [Backbone](http://backbonejs.org)\n- [React](http://facebook.github.io/react/).\n\n将整个站点的代码放入一个文件给代码如何组织带来了巨大挑战。\n所幸, 这里有几个工具能够帮助我们在开发时将代码拆分成一个个小模块(面向对象的开发),最后在发布时再打包在一起, 这时\n该Node大露拳脚了。\n\n\n### Node\n\n[Node](https://nodejs.org) 的核心是用 C 写的一个程序, 允许我们在shell中运行JavaScript(是的, 是终端, 不是浏览器)。\n要做到这些, 他需要使用 Chrome 的 V8 javaScript解释引擎。因此,Node本质上是一个运行环境。\n\n在Node刚被创建出来时,他的主要目标被定位在用javascript来开发web服务端。 在javascript还被限制在客户端的年代中, 这多少有些激进。\n经过一段时间后, web开发者开始意识到使用Node来充当开发工具、依赖管理、和构建项目非常方便。比如:\n\n- [Grunt](http://gruntjs.com/)\n- [Gulp](http://gulpjs.com/)\n- [Browserify](http://browserify.org)\n- [Webpack](http://webpack.github.io)\n\n随着Node变的流行, 许多独立的的开发都和组织开始写Node脚本用来处理一切与web app开发相关的东西。一些开发者上传他们写的Node脚本,\n另一些开发都可以在他们的项目中使用这些脚本, 整个社区能够从这些"第三方Node脚本"获益。 \n\n[Node Package Manager](https://www.npmjs.com/), 简称 “npm”.\nnpm 是一个命令行工具, 可以用来下载和管理第三node javascript用作到你的项目中。 例如文档中的chanjet-ui实际上也是一个npm。\n这意味着你可以将chanjet-ui引入到你的项目中: 只需要` npm install chanjet-ui`, 就可以使用你需要的组件。\n\n这只是一个简短的介绍!\n\n如果你觉得需要了解更多的关于Node知识以便能够快速开始,下面是两个不错的选择:\n\n[blog post](http://openmymind.net/2012/2/3/Node-Require-and-Exports/)\n\n[video](https://www.youtube.com/watch?v=pU9Q6oiQNd0)\n'}});