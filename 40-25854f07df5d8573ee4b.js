webpackJsonp([40],{3:function(n,e,t){n.exports=t(2)(155)},383:function(n,e,t){"use strict";function a(n){return n&&n.__esModule?n:{"default":n}}function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function o(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var g=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),s=t(1),c=a(s),p=t(15),l=(a(p),t(3)),d=a(l),P=t(560),u=a(P),v=function(n){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,n),g(e,[{key:"render",value:function(){return c["default"].createElement("div",null,c["default"].createElement(d["default"],{text:u["default"]}))}}]),e}(c["default"].Component);e["default"]=v},560:function(n,e){n.exports="# Page\n\n\n\nPage 是一个特定的类，代表 NavigationController 导航控制的一个功能模块，在 App 中呈现为应用的每个页面，Navigation Controller 实际上就是管理所有 Page 的队列，确定哪一个 Page 需要显示，哪些 Page 需要隐藏，哪些 Page 需要销毁等等，事实上 NavigationController 和 Page 是密不可分的，两者都无法单独分开使用。\n<div style=\"text-align:center;\"><img src=\"images/navigator/navigator-page.jpg\" /></div><br/>\nPage 在不同的环境中有不同的呈现:\n- #### 在工作圈中\n\n  Page 不包含 Navigate Bar，整个 Page 的显示范围为工作圈 Navigate Bar 以下的空白范围\n\n- #### 在微信、钉钉等手机应用中\n\n  Page 不包含 Navigate Bar，整个 Page 的显示范围为应用中的可用范围\n\n- #### 在手机浏览器中\n\n  Page 不包含 Navigate Bar，整个 Page 的显示范围为浏览器内容显示区域范围\n\n- #### 在PC端浏览器中\n\n  Page包含一个便于开发调试使用的 Navigate Bar，整个 Page 的显示范围为浏览器内容显示区域范围 \n\n<br/><br/>\n## 项目中引用\n\n如果安装的是 chanjet-navigator 的 npm 包：\n```javascript\nimport {Page} from 'chanjet-navigator';\n```\n\n\n<br/><br/>\n## Page 的使用\n\n在项目中引用好 Page 类后，我们可以开始写一个我们应用中的 Page 了:\n\n```javascript\nimport {Page} from 'chanjet-navigator';\n\nexport default class PageIndex extends Page{\n\n    title = '页面标题';\n    \n    className = 'pageClass';\n    \n    navBar = {\n        right: {\n        },\n        onBackClick: this.onBackClick.bind(this),\n        onCloseClick: this.onCloseClick.bind(this)\n    }\n\n\trenderContent(){\n\t    const {params} = this.props;\n        ...  \n\t}\n\n    onBackClick(){\n    }\n\t\t  \n}\n```\n\n- 首先我们要定义一个页面类，并且继承自 chanjet-navigator 的 Page 类，这点很重要，因为 NavigationController 会对管理的 Page 对象做检测，只有继承自 Page 的才认为是一个合法的 Page。 \n- 其次可以定义一个 title ,用于显示当前页面的标题。对应到不同环境中是这样:\n\n  - 工作圈中,作为工作圈的 Navigate Bar 上的标题\n  - 手机应用中,作为应用顶栏上的标题\n  - 手机浏览器中,作为浏览器页面的标题\n  - PC端浏览器中,作为开发模式的 Dev Navigate Bar 的标题\n\n- 再次可以定义一个 className ,作为当前页面容器的一个 css 样式名。\n\n- 还可以定义一个 navBar, 但仅在工作圈和PC端浏览器开发调试模式中有效, <a class=\"careText\" href=\"#/docs/navigator/NavigateBar\">具体使用参照 NavigateBar 部分</a>。\n\n- 给 Page 的页面参数是通过 <span class=\"careText\">this.props.params</span> 来获取的。\n\n- 最后 Page 在渲染的时候会调用 renderContent 来执行 Page 渲染, 使用 render 是没有效果的。\n\n\n\n<br/><br/>\n## Page 的继承\n\n应用开发者可以自己包装一个应用的 App BasePage 类，让应用的页面继承自这个 App BasePage 类，这样可以满足对一些应用页面公共的部分进行包装\n\nApp BasePage\n\n```javascript\nimport {Page} from 'chanjet-navigator';\n\nexport default class BasePage extends Page{\n\t...  \n}\n```\n\nApp Page\n\n```javascript\nimport BasePage from 'app/common/BasePage';\n\nexport default class indexPage extends BasePage{\n\t...  \n}\n```\n\n\n\n\n<br/><br/>\n## Page 的包装\n\n开发应用时也许会用到 Redux ，由于 Redux 会用 connect 将 Page 包装起来，实际上 NavigationController 获取到的是一个Redux 的对象，这样在检测一个应用 Page 是否继承自 chanjet-navigator Page 类时会失败，为此我们针对这种被包装过的 Page 时，我们会检测是否包含 WrappedComponent 属性。如果有，我们会通过 Page.WrappedComponent 拿到真正继承自 chanjet-navigator Page 类的 Page，这样 NavigationController 的合法检测就可以通过了。\n\n目前仅限于对 WrappedComponent 属性的支持，其他方式或第三方库对 Page 的包装如果也实现了 WrappedComponent属性获取真正的 Page ，同样使用起来是没有问题的。如果还其他的包装方式，我们会视使用的普遍程度来进行调整或增加。\n\n\n\n<br/><br/>\n## Page 的生命周期\n\nPage 是一个标准的 React Component, 除了 render 被 renderContent 替代之外, 其他所有的 React Component 的生命周期方法都可以正常使用。\n\n另外作为 chanjet-navigator 的部件, Page 还具有 chanjet-navigator 赋予的其他生命周期方法,包括: \n\n- #### page.active\n\n  当前页面被激活，作为应用的当前显示页\n\n- #### page.unActive\n\n  当前页面转为未激活状态\n\n- #### page.pageBackReceiveResult\n\n  当后一个页面P执行 popAndReturn 后，会将当前页面激活，并调起当前页面的 pageBackReceiveResult 来接收页面P要返回的结果。 \n  <table>\n  ​\t<tr>\n  ​\t\t<td>参数名</td>\n  ​\t\t<td>类型</td>\n  ​\t\t<td>说明</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>action</td>\n  ​\t\t<td>String</td>\n  ​\t\t<td>后一个页面返回的行为, ok 为确定, cancel 为取消</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>result</td>\n  ​\t\t<td>JSON Object</td>\n  ​\t\t<td>后一个页面返回的结果数据</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageCode</td>\n  ​\t\t<td>string</td>\n  ​\t\t<td>在 push 页面时,给页面设置的一个标识,当使用 popAndReturn 回来之后可以依据这个标识来判定返回的行为。避免同一个页面的两个不同行为 push 同一个后续页面时,造成返回时无法识别是哪一个行为触发的。</td>\n  ​\t</tr>\n  </table>\n  <br/>\n\n- #### page.saveInstanceState (仅限在工作圈中)\n\n  保存当前页面的状态数据，该生命周期仅和 Android 系统的手机有关。相关内容请查看 Navigator 的 <a class=\"careText\" href=\"#/docs/navigator/NavigationRestore\">Restore</a> 模式。\n\n- #### page.restoreInstanceState (仅限在工作圈中)\n\n  与 saveInstanceState 成套使用，用于应用恢复状态时，页面的 restoreInstanceState 生命周期方法被调用起来接收之前 saveInstanceState 保存的数据，用于重置状态。\n  \n- #### page.postNavbarMixin\n  \n  在每次渲染页面时先调用，用来在 Page 渲染之前修改 navBar 配置提供时机。\n\n<br/><br/>\n## Page 的懒加载（按需异步加载）\n\n我们在使用ES6开发时，在引用别的类都是采用import方式引入，这是一种同步加载方式，这代表在整个APP开始运行时，所有的 javascript 模块都已经被加载进来，所有的 javascript 代码都会被编译打包到一个完整的 js 文件中，这样往往会造成最后发布的 js 文件过于庞大，浏览器需要更多的加载时间，应用的启动速度也受此影响，一旦网络环境不够好时，带给用户的体验就很糟糕，这时我们往往都是采用按需加载的懒加载方式，希望某些模块只在我需要使用的时候才进行加载，那么在Navigator中如何进行懒加载页面呢？\n\n其实我们只要将 NavigationController 接收的 pages 参数稍加改造就可以实现，方案如下：\n\n```javascript\nconst pages = {\n  '/index':{\n        getComponent(cb) {\n            require.ensure([], (require) => {\n                cb(require('./IndexPage').default);\n            }, 'indexPage');\n        }\n  }\n}\n```\n\n通过这样改造之后，webpack打包就会将 IndexPage 和所涉及的模块都单独打包成一个独立的 js 文件，文件名为 require.ensure 方法的最后一个参数( 示例中会打包出一个 indexPage.js )，在应用 push 页面时再开始加载对应的页面 js 文件。\n\n\n<br/><br/><br/>"}});