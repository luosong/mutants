webpackJsonp([42],{3:function(t,n,e){t.exports=e(2)(155)},381:function(t,n,e){"use strict";function a(t){return t&&t.__esModule?t:{"default":t}}function r(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}function o(t,n){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?t:n}function i(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);t.prototype=Object.create(n&&n.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(t,n):t.__proto__=n)}Object.defineProperty(n,"__esModule",{value:!0});var p=function(){function t(t,n){for(var e=0;e<n.length;e++){var a=n[e];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}return function(n,e,a){return e&&t(n.prototype,e),a&&t(n,a),n}}(),s=e(1),d=a(s),l=e(15),g=(a(l),e(3)),c=a(g),v=e(558),u=a(v),m=function(t){function n(){return r(this,n),o(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return i(n,t),p(n,[{key:"render",value:function(){return d["default"].createElement("div",null,d["default"].createElement(c["default"],{text:u["default"]}))}}]),n}(d["default"].Component);n["default"]=m},558:function(t,n){t.exports="# NavigationController\n\n\n### 简介\n\n<div style=\"text-align:center;\"><img src=\"images/navigator/navigator.jpg\" /></div><br/>\n\nNavigationController 是一个基于栈的页面导航控制管理器，用于管理应用内各种场景页面的切换及应用页面状态恢复，主要包含以下功能：\n\n- #### 应用页面场景的流转\n\n  主要用于页面向前跳转和页面回退的处理。其核心是将页面保存到栈中进行管理，每次渲染只显示栈顶的页面，每跳转到一个新页面，就把这个页面的信息压入栈中，如果要回退到前一个页面，则进行出栈操作，回退到之前的页面去。\n\n\n- #### 将工作圈的 Navigate Bar 上产生的点击事件通知到应用当前场景页面\n\n- #### 页面场景恢复\n\n  主要是针对当前页面被重载时进行的处理。重载发生有以下两种可能，针对这两种场景，解决如何让应用回到之前的状态，包括页面的层级深度，每个页面使用的参数\n\n  - ##### 刷新\n\n  - ##### Android系统中当前页面被杀掉后，重新进入时的场景还原\n\n\n\n<br/>\n## 安装\n\n使用 NavigationController 需要先安装 chanjet-navigator 的 npm 包：\n\n```javascript\nnpm install chanjet-navigator\n```\n\n<br/>\n## 项目中引用\n\n如果安装的是 chanjet-navigator 的 npm 包：\n```javascript\nimport {NavigationController} from 'chanjet-navigator';\n```\n\n如果安装的是 chanjet-ui 的 npm 包：\n```javascript\nimport NavigationController from 'chanjet-ui/lib/navigation/NavigationController';\n```\n\n<br/>\n## 使用\n\n通过简单配置，我们就可以很方便的使用起来了：\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport {NavigationController} from 'chanjet-navigator';\nimport PageIndex from './pages/pageIndex';\nimport PageList from './pages/pageList';\nimport PageDetail from './pages/pageDetail';\n\nconst pages = {\n  '/index':PageIndex,\n  '/list':PageList,\n  '/detail':PageDetail\n}\n\nclass App extends React.Component {\n  render() {\n    return (<NavigationController\n            \tpages = {pages}\n            \trootPage = {'/index'}\n            \trootParams = {{data:'test'}}\n           />);\n  }\n}\n            \nReactDOM.render(<App />, document.getElementById('app'));\n```\n使用参数:\n\n| 参数名        | 类型     | 说明              |\n| ---------- | ------ | --------------- |\n| pages      | Object | 包含所有页面的索引的map对象 |\n| rootPage   | String | 标识起始页要使用的Page   |\n| rootParams | JSON-Object | 起始页Page需要用到的参数  |\n\n\n<br/>\n## 页面流转操作的API\n\n页面流转使用 NavigationController 的 API 方法进行操作，NavigationController 本身会作为 Page 的 props 参数传递到 Page 上，由每个 Page 根据自己的业务发起需要的操作，具体 API 方法如下：\n\n- ### <span class=\"titleDardred\">push</span> \n\n  进入新的页面\n  <div style=\"text-align:center;\"><img src=\"images/navigator/navigator-push.jpg\" /></div><br/>\n  \n  NavigationController 根据 Pages 进行查找对应的 Page 页面，找到后将页面压栈，此时应用切换到新页面，将之前的其他页面进行隐藏。\n  \n  ##### 使用代码\n  ```javascript\n  //API\n  push(pageKey, pageParams, pageCode);\n\n  //在page中具体使用\n  this.props.navigationController.push('/list');\n  this.props.navigationController.push('/list', {params:'test'});\n  this.props.navigationController.push('/list', null, 'page0');\n  ```\n\n  <table>\n  ​\t<tr>\n  ​\t\t<td>参数名</td>\n  ​\t\t<td>类型</td>\n  ​\t\t<td>说明</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageKey</td>\n  ​\t\t<td>String</td>\n  ​\t\t<td>在传入的页面配置对象Pages中的key值</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageParams</td>\n  ​\t\t<td>JSON-Object</td>\n  ​\t\t<td>带给新页面的页面参数</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageCode</td>\n  ​\t\t<td>String</td>\n  ​\t\t<td>给新页面一个标识</td>\n  ​\t</tr>\n  </table>\n  <span class=\"careText\">* pageCode 用于新页面获得结果后返回前一页面时，对新页面的来源判断</span>\n  <br/>\n\n- ### <span class=\"titleDardred\">pop</span>\n\n  返回上一个页面\n  <div style=\"text-align:center;\"><img src=\"images/navigator/navigator-pop.jpg\" /></div><br/>\n  \n  当前页面出栈并被销毁，返回到前一个页面，如果当前页面是唯一页面，则不能再进行 pop 操作。\n  \n  #### 使用代码\n  ```javascript\n  //API\n  pop();\n\n  //在page中具体使用\n  this.props.navigationController.pop();\n  ```\n\n  <br/>\n\n- ### <span class=\"titleDardred\">popTo</span> \n\n  往前查找符合条件的最后一个页面，并返回到该页面\n  <div style=\"text-align:center;\"><img src=\"images/navigator/navigator-popto.jpg\" /></div><br/>\n\n  NavigationController 根据 pageKey 在当前所有页面中查找符合该 pageKey 的最后一个页面，如果找到了就返回到该页面，当前页(包括当前页)到该页面中间所有的页面都出栈，都会被销毁。\n  \n  <span class=\"careText\">* 如果没有找到，则不进行页面跳转，保持不变。</span>\n  \n  ##### 使用代码\n  ```javascript\n  //API\n  popTo(pageKey);\n\n  //在page中具体使用\n  this.props.navigationController.popTo('/index');\n  ```\n  \n  <table>\n  ​\t<tr>\n  ​\t\t<td>参数名</td>\n  ​\t\t<td>类型</td>\n  ​\t\t<td>说明</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageKey</td>\n  ​\t\t<td>String</td>\n  ​\t\t<td>在传入的页面配置对象Pages中的key值</td>\n  ​\t</tr>\n  </table>\n  <br/>\n\n- ### <span class=\"titleDardred\">popToRoot</span> \n\n  回到应用页面栈的第一个页面\n  <div style=\"text-align:center;\"><img src=\"images/navigator/navigator-poptoroot.jpg\" /></div><br/>\n  \n  NavigationController 将当前栈中除第一个页面外的所有页面都出栈并销毁。\n  \n  ##### 使用代码\n  ```javascript\n  //API\n  popToRoot();\n\n  //在page中具体使用\n  this.props.navigationController.popToRoot();\n  ```\n  \n  <br/>\n\n- ### <span class=\"titleDardred\">popAndReturn</span> \n\n  页面出栈并附带返回结果\n  <div style=\"text-align:center;\"><img src=\"images/navigator/navigator-popandreturn.jpg\" /></div><br/>\n  \n  popAndReturn 是一种特定的附带返回行为类型和返回结果到前一个页面的操作。\n  \n  比如从某个页面进入一个拍照页面，拍照结束后可以返回给前一个页面说我拍照完成了，并附带拍好的照片，也可以说我不想拍了，取消拍照的行为。popAndReturn 就是为了处理这种运用场景而设置的。\n  \n  popAndReturn 执行之后，前一个页面如何获得结果? 页面被移除之后，会触发前一个页面的生命周期方法 pageBackReceiveResult，通过这个方法,我们能拿到返回的数据。 \n  \n  <span class=\"careText\">* pageBackReceiveResult 具体用法请查看 Page 的生命周期部分。</span>\n\n  ##### 使用代码\n  ```javascript\n  //API\n  popAndReturn(action, result);\n\n  //在page中具体使用\n  this.props.navigationController.popAndReturn('cancel');\n  this.props.navigationController.popAndReturn('ok', {params:'test'});\n  ```\n\n  <table>\n  ​\t<tr>\n  ​\t\t<td>参数名</td>\n  ​\t\t<td>类型</td>\n  ​\t\t<td>说明</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>action</td>\n  ​\t\t<td>String</td>\n  ​\t\t<td>返回的行为，值为 ok 或 cancel</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>result</td>\n  ​\t\t<td>JSON-Object</td>\n  ​\t\t<td>返回给前一个页面的结果</td>\n  ​\t</tr>\n  </table>\n  <br/>\n\n- ### <span class=\"titleDardred\">replace</span> \n\n  替换当前页面\n  <div style=\"text-align:center;\"><img src=\"images/navigator/navigator-replace.jpg\" /></div><br/>\n\n  replace 即替换当前栈顶页面，同时移除原来的栈顶页面，replace 不限制页面在栈中的位置。\n\n  ##### 使用代码\n  ```javascript\n  //API\n  replace(pageKey, pageParams);\n\n  //在page中具体使用\n  this.props.navigationController.replace('/detail');\n  this.props.navigationController.replace('/detail', {params:'test'});\n  ```\n  \n  <table>\n  ​\t<tr>\n  ​\t\t<td>参数名</td>\n  ​\t\t<td>类型</td>\n  ​\t\t<td>说明</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageKey</td>\n  ​\t\t<td>String</td>\n  ​\t\t<td>在传入的页面配置对象Pages中的key值</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageParams</td>\n  ​\t\t<td>JSON-Object</td>\n  ​\t\t<td>带给新页面的页面参数</td>\n  ​\t</tr>\n  </table>\n  <br/>\n\n- ### <span class=\"titleDardred\">forkTo</span> \n\n  从当前栈的根节点分出新的分支栈\n  <div style=\"text-align:center;\"><img src=\"images/navigator/navigator-forkto.jpg\" /></div><br/>\n\n  NavigationController 首先将根页面以外的全部页面进行出栈移除，然后将要 forkTo 的页面压入栈内，完成从根页面重新进入到另一个分支页面栈，该功能可应用于从当前功能场景快速回到应用首页，然后切换到另一种功能场景。\n  \n  <span class=\"careText\">* 如果要 forkTo 的页面是当前栈的根页面，则回到根页面，而不会在根页面的基础上再加入一个相同的页面，类似于执行了 popToRoot 的操作。</span> \n\n  ##### 使用代码\n  ```javascript\n  //API\n  forkTo(pageKey, pageParams);\n\n  //在page中具体使用\n  this.props.navigationController.forkTo('/detail');\n  this.props.navigationController.forkTo('/detail'', {params:'test'});\n  ```\n  \n  <table>\n  ​\t<tr>\n  ​\t\t<td>参数名</td>\n  ​\t\t<td>类型</td>\n  ​\t\t<td>说明</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageKey</td>\n  ​\t\t<td>String</td>\n  ​\t\t<td>在传入的页面配置对象Pages中的key值</td>\n  ​\t</tr>\n  ​\t<tr>\n  ​\t\t<td>pageParams</td>\n  ​\t\t<td>JSON-Object</td>\n  ​\t\t<td>带给新页面的页面参数</td>\n  ​\t</tr>\n  </table>\n  <br/>"}});